name: Build and Deploy

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      deploy_instance:
        description: 'Deploy to specific instance only (leave empty for all)'
        required: false
        type: string
      skip_deploy:
        description: 'Skip deployment (build and upload only)'
        required: false
        type: boolean
        default: false

env:
  GO_VERSION: '1.22'
  S3_BUCKET: hellotron-vega-deploy
  AWS_REGION: us-east-1

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      binary_uploaded: ${{ steps.upload.outputs.uploaded }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false

      - name: Build binary
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o tron-linux-amd64 ./cmd/tron
          chmod +x tron-linux-amd64

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload binary to S3
        id: upload
        run: |
          aws s3 cp tron-linux-amd64 s3://${{ env.S3_BUCKET }}/binaries/tron-linux-amd64
          echo "Binary uploaded to s3://${{ env.S3_BUCKET }}/binaries/tron-linux-amd64"
          echo "uploaded=true" >> $GITHUB_OUTPUT

      - name: Upload config files to S3
        run: |
          # Upload main config
          if [ -f "tron.vega.yaml" ]; then
            aws s3 cp tron.vega.yaml s3://${{ env.S3_BUCKET }}/config/tron.vega.yaml
          fi
          # Sync knowledge directory
          if [ -d "knowledge" ]; then
            aws s3 sync knowledge/ s3://${{ env.S3_BUCKET }}/config/knowledge/ --delete
          fi
          echo "Config files uploaded to S3"

      - name: Upload versioned binary (on tag)
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          aws s3 cp tron-linux-amd64 s3://${{ env.S3_BUCKET }}/binaries/tron-linux-amd64-${VERSION}
          echo "Versioned binary uploaded: tron-linux-amd64-${VERSION}"

  deploy:
    needs: build
    if: ${{ !inputs.skip_deploy }}
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get target instances
        id: instances
        env:
          DEPLOY_INSTANCE: ${{ inputs.deploy_instance }}
        run: |
          if [ -n "$DEPLOY_INSTANCE" ]; then
            FILTER="Name=tag:Instance,Values=${DEPLOY_INSTANCE}"
          else
            FILTER="Name=tag:Project,Values=hellotron-vega"
          fi

          # Get instance IDs (SSM uses instance IDs, not IPs)
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "$FILTER" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "No running instances found"
            echo "instance_ids=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found instances: $INSTANCE_IDS"
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT

      - name: Deploy via SSM
        if: steps.instances.outputs.instance_ids != ''
        env:
          INSTANCE_IDS: ${{ steps.instances.outputs.instance_ids }}
          S3_BUCKET: ${{ env.S3_BUCKET }}
        run: |
          echo "Deploying to instances: $INSTANCE_IDS"

          # Convert space-separated IDs to comma-separated for SSM
          TARGETS=$(echo $INSTANCE_IDS | tr ' ' ',')

          # Send deployment command via SSM
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=instanceids,Values=$TARGETS" \
            --parameters commands='[
              "set -e",
              "cd /opt/tron",
              "echo \"==> Downloading new binary from S3...\"",
              "aws s3 cp s3://'"$S3_BUCKET"'/binaries/tron-linux-amd64 /tmp/tron-new",
              "chmod +x /tmp/tron-new",
              "echo \"==> Downloading config files...\"",
              "aws s3 cp s3://'"$S3_BUCKET"'/config/tron.vega.yaml /tmp/tron.vega.yaml || true",
              "aws s3 sync s3://'"$S3_BUCKET"'/config/knowledge/ /tmp/knowledge/ || true",
              "echo \"==> Stopping tron service...\"",
              "sudo systemctl stop tron || true",
              "echo \"==> Replacing binary...\"",
              "mv /tmp/tron-new ./tron",
              "echo \"==> Syncing config files...\"",
              "[ -f /tmp/tron.vega.yaml ] && mv /tmp/tron.vega.yaml ./",
              "[ -d /tmp/knowledge ] && rsync -a /tmp/knowledge/ ./knowledge/ && rm -rf /tmp/knowledge",
              "echo \"==> Starting tron service...\"",
              "sudo systemctl start tron",
              "sleep 3",
              "echo \"==> Verifying service...\"",
              "systemctl is-active --quiet tron && echo \"Service running\" || (journalctl -u tron -n 20 --no-pager && exit 1)",
              "echo \"==> Health check...\"",
              "curl -sf http://localhost:3000/health && echo \"Health OK\" || (echo \"Health check failed\" && exit 1)",
              "echo \"==> Deployment complete!\""
            ]' \
            --timeout-seconds 120 \
            --query 'Command.CommandId' \
            --output text)

          echo "Command ID: $COMMAND_ID"

          # Wait for command to complete
          echo "Waiting for deployment to complete..."
          for i in {1..30}; do
            sleep 5
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --query 'CommandInvocations[0].Status' \
              --output text 2>/dev/null || echo "Pending")

            echo "Status: $STATUS"

            if [ "$STATUS" = "Success" ]; then
              echo "Deployment successful!"

              # Get output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$(echo $INSTANCE_IDS | awk '{print $1}')" \
                --query 'StandardOutputContent' \
                --output text || true

              exit 0
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Deployment failed with status: $STATUS"

              # Get error output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$(echo $INSTANCE_IDS | awk '{print $1}')" \
                --query '[StandardOutputContent, StandardErrorContent]' \
                --output text || true

              exit 1
            fi
          done

          echo "Deployment timed out waiting for SSM command"
          exit 1
